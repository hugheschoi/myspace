`pnpm`是一个类似于`npm`和`yarn`的Node.js包管理器，它可以帮助你更有效地管理你的项目依赖项。相较于其他包管理器，`pnpm`提供了以下优点：

1. 更快的安装速度：`pnpm`采用符号链接来管理全局依赖和本地依赖，因而只会在第一次安装时下载一份，节省了磁盘空间和网络带宽。此外，`pnpm`可以同时下载和安装多个包，并使用并行处理机制来最大化利用系统资源。
2. 更少的磁盘空间占用：与`npm`和`yarn`不同，`pnpm`每个依赖项只有一份实际的拷贝，这使得磁盘空间占用量大大减少。
3. 性能更稳定：如果在某些单个版本依赖项上安装失败，则支持回滚到原始安装状态，并从缓存中重新启动安装过程，以保证安装的完整性。
4. 无需`node_modules`文件夹：相比之下，`pnpm`会在需要时自动创建软连接，从而使得本地安装的包可以在所有项目之间共享。

总之，`pnpm`是一个非常好的包管理器，它可以让你更高效地处理你的项目依赖项。如果你正在使用Node.js，并且想要提高你的开发效率和速度，那么我强烈建议你尝试一下`pnpm`！



## 更快的安装速度

`pnpm` 采用符号链接（symbolic links）来管理全局依赖和本地依赖，这是通过打破 `npm` 和 `yarn` 原有的软连接方式，直接访问文件系统上已经存在的模块包实现的。相较于传统的 `npm` 或 `yarn` 每个项目单独安装依赖项，`pnpm` 在本地只需保存一个全局库的引用和一个名为 `.modules` 文件夹，存储所有的依赖项。

以下是 `pnpm` 所采用的工作原理：

1. `pnpm` 安装依赖时会先在本地 `.modules` 目录下搜索要安装的依赖是否被其他项目安装过，并且该版本是否与要安装的版本匹配。若是，则会在编译后的项目目录中使用相关的符号链接指向对应的模块目录；
2. 若前置条件不满足，则会从仓库中下载对应版本的依赖项并添加到 `.modules` 文件夹中；
3. 当要启动一个项目时，`pnpm` 会将 `node_modules` 文件夹下的依赖文件夹全部重定向至 `.modules` 目录下对应的全局依赖项，这样不用对每个项目都重复安装同样的依赖项。当项目结束之后，`pnpm` 会自动重定向回本地的项目依赖库，并清理无用模块。

通过 `pnpm` 的这种方式管理依赖项带来了一些好处，例如：

1. 节省磁盘空间。在传统方式下，每个项目都需要安装一份完整的依赖项，容易造成重复下载和浪费；
2. 加速模块安装。由于已安装的模块可以在多个项目中重用，因此不需要每次都下载和编译源代码，采用符号链接可以大大减少安装时间；
3. 更高效的更新机制。当一个新版本发布时，只需要在全局 `.modules` 目录下保存该版本，其他项目可以随时升级并重新使用其中的符号链接。

## 实践

以下是一些`pnpm`的不错实践：

1. 将`pnpm`作为默认包管理器：如果您已经使用了`npm`或`yarn`，则可以在您的开发生命周期中使用`pnpm`。可以通过使用`npx`或直接全局安装来进行安装。例如，要全局安装`pnpm`，您可以运行以下命令：

   DiffCopyInsertNew

   ```
   npm install -g pnpm
   ```

2. 与其他工具结合使用： `pnpm` 可以很好地与其他工具结合使用，例如 TypeScript、Webpack 等。在使用 TypeScript 的时候，可以设置 tsconfig.json 文件中的 rootDirs 属性，指定源代码目录路径和 node_modules 目录路径，从而让 TypeScript 通过编译，无需手动更改导入语句。例如：

   DiffCopyInsertNew

   ```
   //tsconfig.json
   {
     "compilerOptions": {
       "rootDir": "./src",
       "outDir": "./dist",
       "module": "commonjs",
       "target": "es5"
     }
   }
   ```

3. 多项目共享依赖：在开发多个项目时，您可以在同一个文件夹中运行`pnpm`，然后每个项目都可以共享相同的依赖项，而不必重复下载它们。在这种情况下，`pnpm-store`文件夹将会是所有项目所共享的存储位置。

4. 使用 Workspaces（工作区）：`Workspaces` 是一组相关的包的根目录，它们在同一工作区中被管理。`pnpm`支持 Workspaces，在其中多个包可以共享相同的依赖项。要使用 `Workspaces`，您需要在项目根目录下创建一个名为 `package.json` 的文件，并指定您想要创建工作区的路径，如下所示：

   DiffCopyInsertNew

   ```
   // package.json
   {
     "name": "my-workspace",
     "version": "0.1.0",
     "private": true,
     "workspaces": [
       "packages/*"
     ]
   }
   ```

5. 使用`.npmrc`文件：类似于其他包管理器，`pnpm`也支持 `.npmrc` 文件。通过在该文件中指定常用的选项和配置参数，您可以节省很多时间。例如，您可以指定默认的 registry（镜像源），以加快包下载速度。

总之，这些是使用`pnpm`的一些不错的实践。当然，最终的实践方法会因您的具体开发场景而异。我希望这些建议能够对您有所帮助！



## 核心工作原理

`pnpm` 的核心工作原理就是符号链接（symbolic links）来管理依赖项。与传统的 `npm` 或 `yarn` 每个项目单独安装依赖项不同，`pnpm` 在本地只需保存一个全局库的引用和一个名为 `.modules` 文件夹，存储所有的依赖项。

以下是 `pnpm` 的基本流程：

1. 当你在本地启动一个项目时，`pnpm` 会检查 `.modules` 中是否存在对应版本的依赖项。若已经存在，则会将该依赖项中的模块文件夹复制到项目的 `node_modules` 文件夹下，并创建一个符号链接指向对应的模块目录；
2. 若该依赖项未被缓存在 `.modules` 中，则会从仓库中下载对应版本的依赖项并添加到 `.modules` 文件夹中，然后执行第一步的操作；
3. 当要启动一个新项目时，`pnpm` 会检查项目中的 `node_modules` 是否符号链接指向了全局的 `.modules` 目录，如果没有则会自动重定向，这样可以避免每个项目都重复安装同样的依赖项；
4. 当你安装或卸载一个依赖项时，`pnpm` 会先更新 `.modules` 目录下对应的依赖项的版本，并将其更新到全局引用的依赖库中。然后会在对应的项目目录中创建或删除符号链接，并将 `package.json` 中的依赖信息更新。

通过采用符号链接，`pnpm` 实现了多个项目共享一份本地缓存，从而提高了安装依赖项的速度和效率，并减少了磁盘空间的使用。