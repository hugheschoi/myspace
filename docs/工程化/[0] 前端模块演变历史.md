灵感来源：[重学webpack系列(一) -- 前端模块化的演变历史 - 掘金 (juejin.cn)](https://juejin.cn/post/7145356999055081486)，读完后的总结，以及对其内容的思考和解疑。

> 模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。--来自百度百科，

### 早期模块化

```html
<script src="./a.js"></script>
<script src="./b.js"></script>
<script src="./c.js"></script>
```

思考一下，这样会有什么问题？

- 变量名、函数名等命名冲突
- 全部暴露，产生超多的全局变量
- 无法处理模块间的依赖关系，全部一次性加载完毕
- 其他问题？

**早期的解决方案：**

1.命名空间和模块化

每一个文件只允许暴露出一个全局对象，文件里的所有属性都必须暴露在对象里面，以达到解决重复的问题。

```js
window.moduleA = {
  data: {...},
  getData: function() {},
};
```

紧接着社区又约定了一种`IIFE`的方式，也就是在第二种的形势下，在外层包裹了一层自执行函数。

```js
(function(message){
  const a = 'a';
  const b = 'b';
  const getData = function(){};
  console.log(message);  // 'Hello, World!'
  window.getModuleAData = getData; // 可以暴露全局变量，但也有变量名冲突的风险
  // 也可以通过 return 暴露，具体方法用到的时候可以查一下
})('Hello, World!')
```

**早期的解决方案又还存在什么问题？**

上述三种方式为最早的社区约定的模块化方式，确实能够解决一些问题，但是同学们有没有发现，这三种方式都是通过`script`标签进行引入到`html`页面的，也就是`同步`加载的，如果在很复杂的具有多个请求的场景下使用的话，那么这些`ajax`将会是同步发起的，会带来很大的`性能问题`，为了解决这个`加载方式`的问题，社区又提出了一个新的规范，那就是`AMD (Asynchronous Module Definition)`。

### 模块化青铜器时代

AMD的设计灵感来自于以往开发者的约定俗成的规范的统一：

- 灵感一：用`script`引入一个文件到页面中，其余模块能不能够用代码控制按需加载。
- 灵感二：前端行业蒸蒸日上，能不能设计一个符合行业的统一的规范。
- 灵感三：设计的基础库应该能够实现模块的自动加载。
- 灵感四：可以借鉴于`Common.js`实现的模块化规范。

`Common.js`规范 `Common.js`规范，是`Node.js`中所遵循的模块化规范，该规范规定，每一个文件就是一个模块，每个模块有自己单独的作用域，通过`module.exports`导出成员，通过`require`导入另外的模块。

AMD规范，即Asynchronous Module Definition，是一种异步模块加载的机制。它是一种规范，定义了如何在JavaScript环境下，实现异步加载和依赖管理模块的机制。

在AMD规范出现之前，JavaScript模块的加载和依赖管理都是比较混乱的。不同的开发者和团队有不同的做法，例如使用全局变量、回调函数、立即执行函数表达式（Immediately Invoked Function Expression，IIFE）等。这导致了代码的重复和冗余，同时也增加了代码的维护难度。

AMD规范的出现解决了这个问题。它提供了一种统一的模块定义方式，使得开发者可以按照规范编写模块，并且可以异步加载模块。这种方式不仅可以减少代码的重复和冗余，还可以提高代码的可维护性和可重用性。

AMD规范的主要特点包括：

1. 模块定义：AMD规范使用一个define函数来定义模块，该函数接受一个字符串作为模块的名称，一个回调函数作为模块的内容，以及一个可选的依赖列表。
2. 依赖管理：AMD规范使用require函数来加载依赖模块。该函数接受一个依赖列表，并执行回调函数来处理这些依赖。
3. 异步加载：AMD规范支持异步加载模块，这样可以提高页面的性能和响应速度。

AMD规范的出现对于JavaScript模块化的发展起到了重要的推动作用。它提供了一种统一、标准、可维护的模块定义方式，使得JavaScript的开发更加高效和便捷。

### 现代模块化规范

ESM（ECMAScript Module）规范是JavaScript的模块化规范，它是在ECMAScript 6（ES6）中引入的。ESM规范提供了一种模块化解决方案，使得JavaScript可以使用静态导入和导出语法来组织和管理代码。

ESM规范的主要特点包括：

1. 模块定义：ESM规范使用export命令来定义模块的对外接口。例如，export let myVariable = 'Hello World';
2. 模块导入：ESM规范使用import命令来导入其他模块提供的功能。例如，import { myVariable } from './myModule.js';
3. 静态导入：ESM规范的模块导入是在编译时进行的，而不是在代码运行时加载。这意味着可以在编译时确定模块的依赖关系和输入输出的变量。
4. 动态导入：虽然ESM规范在语法上支持静态导入，但实际上它也支持动态导入。动态导入可以在运行时加载模块，适用于一些需要按需加载的场景。

总的来说，ESM规范提供了一种简单、静态的模块化解决方案，使得JavaScript可以在ES6及以上版本中实现模块化功能，并且可以与现有的框架和工具集成。

### ESM的特性

- 自动采用严格模式（在严格模式中`this`不会默认指向`window`对象）。
- 每个`ESM`都有单独的私有作用域。
- `ESM`是通过`CORS`去请求外部`js`模块的，被访问的地址需要支持`CORS`。
- `ESM`的`script`标签会延迟执行脚本，不会阻塞浏览器渲染，相当于加了`defer`属性。
- `ESM`的模块导入导出。



ESM规范的出现提供了一种原生、静态的模块化解决方案，使得JavaScript可以使用静态导入和导出语法来组织和管理代码。这种解决方案更加简洁、易于使用，并且可以与现有的打包工具和框架集成。

![289a0a5f284747c6ac6aecdc44fd6098~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0](/Users/zhuangbing.cai/Documents/myspace/documents/docs/images/289a0a5f284747c6ac6aecdc44fd6098~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)



模块化是对管理代码、组织代码的一种解决方案，从一开始的IIFE、到后来的异步模块加载，再到最后的 ESM 规范（官方规范），都朝着更优的代码管理方式、更好的浏览器加载性能发展的。这些规范的发展也与工具链的发展有一定关系（webpack）

### 用一段话总结



