### 删除排序数组中的重复项

题目：升序数组，原地删除重复的元素，并返回删除后的数组长度

- `1 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **升序** 排列

边界条件：nums 的长度如果是0或1， 则返回 0或1

示例：

```txt
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
```

解法一:  双指针

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    if (nums.length <= 1) return nums.length;
  	let left = 0;
  	for (let right = 1; right < nums.length; right++) {
      if (nums[left] !== nums[right]) {
        nums[++left] = nums[right]
      }
    }
  	return left + 1;
};
```

改良后的解法：

```js
var removeDuplicates = function(nums) {
    let i = 0;
    for (let n of nums) {
        if (nums[i] !== n) {
            nums[++i] = n
        }
    }
    return i + 1;
};
```



国际版中找优秀的解法

1. 记录连续重复的长度，一旦出现不同，则将这个连续重复的第一个元素设置为新的值

```js
var removeDuplicates = function(nums) {
  const n = nums.length;
  let count = 0;
  for(let i = 1; i < n; i++){
    if(nums[i] == nums[i-1]) count++;
    else nums[i-count] = nums[i];
  }
  return n - count;
};
```

2. 也是双指针，不过用的是 for .. of ，因为这个指针正常按数组循环走，所以就直接用 for ... of 比较合适

```js
function removeDuplicates(nums) {
    let i = 0;
    for (let n of nums) {
        if (i === 0 || n > nums[i - 1]) {
            nums[i++] = n;
        }
    }
    return i;
}
```

总结：

双指针解法，学到了**使用 for of 的方式循环**的方法



### 买卖股票的最佳时机 II

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 。

示例：

输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。

解法一： 贪心算法

分析：求最优解的时候一般可以用到贪心算法，该题就是求最佳买卖时机。

过程：求每一步状态下的最优解

那么这个问题每一步最佳解是什么？

那就是只要当前的股票高于昨天，就应给把股票卖出, 利润就是差价: `price[i]> price[i-1]? res += price[i]-prices[i-1]`

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let profit = 0;
    for (let i = 0; i < prices.length; i++) {
        if (prices[i+1] > prices[i]) {
            profit += prices[i+1] - prices[i]
        }
    }
    return profit;
};
```

解法二： 动态规划

**什么是最优子结构？**

一个问题的解可以通过一些子问题的最优解求得，最优子结构是设计动态规划算法的核心思想之一。如果一个问题具有最优子结构，那么我们可以使用动态规划算法来解决它，**通过存储子问题的解**来避免重复计算，从而大大降低算法的时间复杂度。

**怎么理解动态规划**？

动态规划是一种求解最优化问题的算法，它的核心思想是将原问题分解成一系列子问题，通过保存子问题的解，避免重复计算，从而实现高效的求解。

**如何创建二维数组**

```js
const row = 3;
const col = 4;
const dp = Array.from({ length: row }, () => Array(col).fill(0));
```

**这道题的最佳子结构是什么?**

最后一天的最大利润是，第 i 天的最大利润，且不持有股票，存储两种方式的最大利润：

1. 当第 i 天持有股票的最大利润为 ：`dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]) ` 
2. 当第 i 天不持有股票的最大利润为：`dp[i][0] = Math.max(dp[i-1][1] + prices[i], dp[i-1][0])`

那么最后一天的最大利润为： `dp[prices.length - 1][0]`

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
 	const n = prices.length;
  const dp = Array.from({length: n}, () => Array(2).fill(0));
  // 边界条件
  dp[0][0] = 0;
  dp[0][1] = -prices[0];
  for (let i = 1; i < n; i++) {
    dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
    dp[i][0] = Math.max(dp[i-1][1] + prices[i], dp[i-1][0])
  }
  return dp[n-1][0];
};
```

**国际版的高赞题解**

一、也是类似贪心算法，求买入和卖出的最小子问题。

1. 买入的最小子问题是：当明天的价格高于今天，就买入
2. 卖出的最小子问题：当明天的价格低于今天，就卖出

```js
function maxProfit(prices) {
  let i = 0, buy, sell, profit = 0, N = prices.length - 1;
  while (i < N) {
    while (i < N && prices[i + 1] <= prices[i]) i++;
    buy = prices[i];

    while (i < N && prices[i + 1] > prices[i]) i++;
    sell = prices[i];

    profit += sell - buy;
  }
  return profit;
}
```

二、这个求解也很有意思，使用了 for of 就解决了，也是解决了子问题。

有两个存储，一个是今天持有股票和今天不持有股票，并赋予初始值，并随着循环，更新这两个值，最后返回不再持有股票的值。

```js
var maxProfit = function(prices) {
    
    // It is impossible to sell stock on first day, set -infinity as initial value for curHold
    let [curHold, curNotHold] = [-Infinity, 0];
    
    for(const stockPrice of prices){
        
        let [prevHold, prevNotHold] = [curHold, curNotHold];
        
        // either keep hold, or buy in stock today at stock price
        curHold = Math.max(prevHold, prevNotHold - stockPrice );
        
        // either keep not-hold, or sell out stock today at stock price
        curNotHold = Math.max(prevNotHold, prevHold + stockPrice );
    }
    
    // Max profit must come from notHold state finally.
    return curNotHold; 
};
```

三、这个解法也很简便，也是贪心算法

```js
function maxProfit(prices) {
  const n = prices.length;
  let ans = 0;
  for (let i = 1; i < n; i++) {
    ans += Math.max(0, prices[i] - prices[i - 1]);
  }
  return ans;
}
```

总结

1. 最优子问题
2. 使用动态规划存储最佳子问题的解



### 旋转数组

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

```text
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

解法一：旋转整个数组，在旋转前k个，和旋转 k 后面的

```js
var rotateArray = function(nums, start, end) {
    while (start < end) {
        let temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;
        end--;
    }
}
var rotate = function(nums, k) {
    const n = nums.length;
    k %= n;
    rotateArray(nums, 0, n - 1);
    rotateArray(nums, 0, k-1);
    rotateArray(nums, k, n - 1);
};
```

解法二：可以直接用数组的方法

```js
var rotate = function(nums, k) {
   k %= nums.length;
   nums.unshift(...nums.splice(nums.length - k))
};
```

国际版高赞回复：



总结：

学到 k %= n 这个操作（求余， 比如 2%2 2除以2 余数是 0， 等于0），主要是为了避免 k 大于数组的长度而导致错误。

1%2 = 1; 2%2 = 0; 3%2 = 1，如果被除的数比较大，那就返回除的数

### 存在重复元素

给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。

```
输入：nums = [1,2,3,1]
输出：true
```

1. 哈希表
2. 先排序，再前后对比
3. 利用 Set，比较长度

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
// var containsDuplicate = function(nums) {
//     const map = {};
//     for (let i = 0; i < nums.length; i++) {
//         if (map[nums[i]]) {
//             return true;
//         } else {
//             map[nums[i]] = true;
//         }
//     }
//     return false
// };
// var containsDuplicate = function(nums) {
//     nums.sort();
//     for (let i = 0; i< nums.length;i++){
//         if (nums[i]===nums[i+1]) return true;
//     }
//     return false;
// }
var containsDuplicate = function(nums) {
    const newArr = Array.from(new Set(nums));
    return newArr.length !== nums.length;
}
```

国际版高赞：



### 只出现一次的数字

给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

```
输入：nums = [2,2,1]
输出：1
输入：nums = [4,1,2,1,2]
输出：4
```

1. 位运算
2. Set

```js
var singleNumber = function(nums) {
    let res = 0;
    for (let i = 0; i < nums.length; i++) {
        res ^= nums[i];
    }
    return res;
};

var singleNumber = function(nums) {
    const set = new Set();
  	for (let n of nums)                                {
      if (set.has(n)) {
        set.delete(n);
      } else {
        set.add(n)
      }
    }
  	return Array.from(set)[0];
};                                
```

总结：

异或运算满足：与自己异或 = 0，与 0 异或 = 自己,异或运算具有交换律

a^a = 0; a^0 = a;  a^b^c = c^a^b



