### 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

分析：

1. 使用前后双指针，互相交换，注意移动指针
2. 边界条件 1<= s.length <= 105

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
  if (s.length <= 1) return s;
	let left = 0;
  let right = s.length - 1;
  while (left < right) {
    const temp = s[left];
    s[left++] = s[right];
    s[right--] = temp
  }
};
```



### 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

**示例 1：**

```
输入：x = 123
输出：321
```

**示例 2：**

```
输入：x = -123
输出：-321
```

`-231 <= x <= 231 - 1`

分析：

1. 不允许储存额外空间，那就不能转成字符串了，需要用 %10 得到 个位数，使用 Math.trunc 去整数
2. 有边界条件，结果不在范围就返回 0，使用 Math.pow(2, 31)
3. 要怎么循环呢？变化x，只要x > 0 就继续, x = Math.trunc(x / 10);

```js
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
  	let res = 0;
  	const max = Math.pow(2, 31) - 1;
  	const min = -Math.pow(2, 31)
    while (x !== 0) {
      let curr = x % 10;
      x = Math.trunc(x / 10);
      res = res * 10 + curr;
      if (res > max || res < min) return 0;
    }
  	return res;
};
```



### 字符串中的第一个唯一字符

给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。

```
输入: s = "leetcode"
输出: 0

输入: s = "loveleetcode"
输出: 2

输入: s = "aabb"
输出: -1
```

提示:

1 <= s.length <= 105
s 只包含小写字母



分析：

1. ~~维护一个hash表，记录该字符串对应的下标，如果又遇到了，值加 1~~
   维护一个 hash 表，记录每个字母出现的次数

2. ~~怎么做这个hash 表？ Map 是有顺序的吗？有 `myMap.entries().next().value` 返回第一个元素~~
   用对象就好了，可以遍历 s 保证顺序，只要遇到值只出现一次，那么就直接返回下表

   

```js
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
	const map = {};
  for (let i = 0 ; i < s.length; i++) {
    if (map[s[i]] !== undefined) {
      map[s[i]] += 1;
    } else {
      map[s[i]] = 1
    }
  }
  for (let i = 0 ; i < s.length; i++) {
    if (map[s[i]] === 1) {
      return i;
    }
  }
  return -1;
};
```



### 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

```
输入: s = "anagram", t = "nagaram"
输出: true

输入: s = "rat", t = "car"
输出: false
```

**提示:**

- `1 <= s.length, t.length <= 5 * 104`
- `s` 和 `t` 仅包含小写字母

分析：

1. 使用 hash 记录 s 中每个字母的出现次数，然后在 t 找，如果出现一次就减一。最后查看这个hash 表，是否值都为0



```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    const map = {};
    for (let i = 0;i < s.length;i++) {
        if (map[s[i]] !== undefined) {
            map[s[i]] += 1;
        } else {
            map[s[i]] = 1;
        }
    }
    for (let i = 0;i < t.length;i++) {
        if (map[t[i]] !== undefined) {
            map[t[i]] -= 1;
        } else {
            return false;
        }
    }
    for (let key in map) {
        if (map[key] !== 0) return false;
    }
    return true;
};
```



### 总结

1. 双指针
2. 遍历数字 -> 每次除以 10（Math.trunc）,直到 等于0 为止，用 %10 运算获取当前遍历的个位数
3. 哈希表
4. 哈希表顺序问题，可以循环原来的数组（利用原来的数组的顺序）再去哈表表对照看看

